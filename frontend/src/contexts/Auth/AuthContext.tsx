import { createContext, useContext, useEffect, useState } from 'react';
import { toast } from 'sonner';
import { setAuthFailHandler } from '@/services/api';
import { getAuthentication } from '@/services/generated/authentication/authentication';
import type { LoginDto, SessionPayload } from '@/services/generated/models';

//*************************************************************
//* Tipagens para o contexto
//*************************************************************
function useAuthProvider() {
  //const { registerCommand, unregisterCommand } = useSseContext();
  const [sessionPayload, setSessionPayload] = useState<SessionPayload | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const isAuthenticated = !!sessionPayload;
  const { authenticationControllerCheckSession, authenticationControllerLogin, authenticationControllerLogout } =
    getAuthentication();

  //?????????????????????????????????????????????????????????????????????????????????
  //? Metodos do contexto
  //?????????????????????????????????????????????????????????????????????????????????
  async function signInHandler(data: { credentials: LoginDto; rememberMe: boolean }) {
    if (!data.credentials.username || !data.credentials.password || data.rememberMe === null) {
      toast.error('Dados de login inválidos!');
      return;
    }
    await authHandler(data.credentials);
  }

  async function signOutHandler() {
    try {
      await authenticationControllerLogout();
    } catch {}
    setSessionPayload(null);
  }

  //?????????????????????????????????????????????????????????????????????????????????
  //? internal methods
  //?????????????????????????????????????????????????????????????????????????????????
  async function authHandler(params?: LoginDto, setLoad = true) {
    if (setLoad) {
      setIsLoading(true);
    }

    try {
      let data: SessionPayload;
      if (params) {
        data = await authenticationControllerLogin(params);
      } else {
        data = await authenticationControllerCheckSession();
      }

      setPayload(data);
    } catch (error) {
      if (sessionPayload || params) {
        toast.error(error instanceof Error ? error.message : 'Erro ao autenticar!');
      }
      setSessionPayload(null);
    } finally {
      if (setLoad) {
        setIsLoading(false);
      }
    }
  }

  function setPayload(data: SessionPayload | null) {
    if (data?.firstname) {
      setSessionPayload(data);
      return;
    }

    //!aqui só se a VITE_API_URL estiver apontando pra pra lugar errado que não de erro ao requisitar /login
    toast.error('Erro ao autenticar!');
    setSessionPayload(null);
  }

  //? metodo interno para limpar o usuário (que será dado para o serviço 'api' usar - use effect abaixo)
  function invalidateAuth() {
    if (!isAuthenticated) {
      return;
    }
    setSessionPayload(null);
  }

  //?????????????????????????????????????????????????????????????????????????????????
  //? useEffects
  //?????????????????????????????????????????????????????????????????????????????????
  useEffect(() => {
    //!tenta buscar a sessao, se cookies ainda forem validos, já vai 'autenticar'
    void authHandler();
  }, []);

  useEffect(() => {
    //! jogar processo de 'desautenticar' o usuário para service 'api' poder usar
    setAuthFailHandler(invalidateAuth);
  }, [invalidateAuth]);

  //?????????????????????????????????????????????????????????????????????????????????
  //? Retornos do Context
  //?????????????????????????????????????????????????????????????????????????????????
  return {
    isAuthenticated,
    isLoading,
    userData: sessionPayload,
    signIn: signInHandler,
    signOut: signOutHandler,
  };
}
export type AuthContextType = ReturnType<typeof useAuthProvider>;

//*************************************************************
//* Criando o contexto, com base no tipo acima
//*************************************************************
//! mantem privado pra forçar o uso de useAuthContext
const AuthContext = createContext<AuthContextType | undefined>(undefined);

//*************************************************************
//* Componente Provider do contexto (onde são iniciadas as
//* variáveis de estado e as funções que serão passadas no value)
//* E então passadas no value para serem usadas pelos componentes filhos
//*************************************************************
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuthProvider();
  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
}

//*************************************************************
//* Wrappers para o contexto, de modo que não precise ser chamado
//* useContext([name]Context) diretamente. Mas sim 'use' abaixo
//* que já faz a verificação de undefined e retorna o contexto
//*************************************************************
export function useAuthContext() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

//! por que não usar os loadings dos slices:
//! como são dois loadings distintos, de depois processos interdependentes, ocorre de
//! ao processar o authSlice ele terminar o loading e o userSlice ainda não iniciou
//! isso faz as paginas de login e home darem o flicker pois efetivamente ele está
//! num estado intermediario e ainda não autenticado mas sem loading (pegou o jwt mas
//! ainda nao processou o 'me')
